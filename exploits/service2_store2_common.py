#!/usr/bin/env python3

import zlib
import base64
import json
from Crypto.Cipher import AES
import sys
import string
import random
from hashlib import sha256
import os
os.environ["PWNLIB_NOTERM"] = "1"

from pwn import remote, context
from service2client import Client as AuthClient

context.log_level = "error"
PORT = 1236


def random_string(min, max):
    letters = string.ascii_letters + string.digits
    return ''.join(random.choice(letters) for i in range(random.randint(min, max)))


# Auth stuff
def get_random_creds():
    username = random_string(8, 24)
    password = random_string(8, 24)
    return username, password


def register_random_user(team_ip):
    username, password = get_random_creds()
    register_user(team_ip, username, password)
    return username, password


def register_user(team_ip, username, password):
    c = AuthClient(team_ip, username, password, "3")
    c.register()


def get_token(team_ip, username, password):
    c = AuthClient(team_ip, username, password, "3")
    c.login()
    token = c.get_token()
    return token


# OT stuff
class Receiver:
    def __init__(self, b):
        self.b = b

    def round2(self, pk, x):
        N, e = pk
        n = len(x)
        assert n == len(self.b)

        v = []
        for i in range(n):
            cur = x[i][0]
            v.append(cur % N)
        self.N = N
        self.x = x
        return v

    def decode(self, c):
        n = len(c)
        assert n == len(self.b)

        m = []
        for i in range(n):
            mm = (c[i][0]) % self.N
            m.append(mm)
        return m


# client to service
def bytes2bits(b):
    bits = ''.join(f'{x:08b}' for x in b)
    return list(map(int, bits))


def bits2bytes(arr):
    n = len(arr)
    assert n % 8 == 0
    nbytes = n // 8
    s = "".join(map(str, arr))
    return int.to_bytes(int(s, 2), nbytes, "big")


class Client:
    def __init__(self, host, token):
        self.r = remote(host, PORT)
        self.r.recvlines(1)
        self.r.sendlineafter("token: ", token)

    def set_keyword(self, keyword):
        self.r.recvlines(6)
        self.r.sendlineafter("> ", "1")
        self.r.sendlineafter("secret: ", keyword)

    def set_public(self, data):
        self.r.recvlines(6)
        self.r.sendlineafter("> ", "2")
        self.r.sendlineafter("text: ", data)

    def get_public(self, user):
        self.r.recvlines(6)
        self.r.sendlineafter("> ", "4")
        self.r.sendlineafter("user: ", user)
        return self.r.recvline(False).decode()

    def run_function(self, choice, user, my_in):
        self.r.recvlines(6)
        self.r.sendlineafter("> ", "3")
        self.r.sendlineafter("user: ", user)
        self.r.recvlines(3)
        self.r.sendlineafter("> ", str(choice))

        data = self.r.recvline(False)
        tmp = zlib.decompress(base64.b64decode(data))
        obj = json.loads(tmp.decode())
        circ = obj["circuit"]

        N, e, x = obj["ot"]["N"], obj["ot"]["e"], obj["ot"]["x"]
        in_B = bytes2bits(my_in)
        assert len(in_B) == 128

        if choice == 2:
            in_B = in_B[::-1]
        receiver = Receiver(in_B)
        v = receiver.round2((N, e), x)
        vdict = json.dumps({"v": v})
        self.r.sendline(vdict)
        data = self.r.recvline(False)
        obj = json.loads(data.decode())
        c = obj["c"]

        return circ, (receiver.N, c, receiver.x)


# circuits stuff
VAL_LENGTH = 5
PAD_LENGTH = 3


def xor(a, b):
    return bytes(x ^ y for x, y in zip(a, b))


def H(k):
    return sha256(k).digest()


def dec(k, x):
    k = H(k)
    val = xor(k, x)
    if val[:PAD_LENGTH] == b"\0"*PAD_LENGTH:
        return val[PAD_LENGTH:]


def decode_gate(opv, g, ins, to_hex):
    if to_hex:
        ins = [bytes.fromhex(x) for x in ins]
        g = [bytes.fromhex(r) for r in g]
    if opv == "INV":
        res = ins[0]
    elif opv == "XOR":
        res = xor(ins[0], ins[1])
    else:
        for x in g:
            k = b"".join(ins)
            val = dec(k, x)
            if val is not None:
                res = val
                break
    if to_hex:
        return res.hex()
    return res


def my_evaluate(garbled_circuit, inputs, target_id):
    enc_A, enc_B = inputs
    vals = enc_A+enc_B+[None]*len(garbled_circuit)
    for g in garbled_circuit:
        idx, opv, ins, gate = g
        k = [vals[i] for i in ins]
        cur = decode_gate(opv, gate, k, True)
        assert cur is not None
        vals[idx] = cur
        if idx == target_id:
            return cur


def get_b(garbled_circuit, enc_A, enc_B_all):
    indici = {3535: (19, 18), 3532: (23, 18), 3530: (21, 17), 3529: (20, 17), 3674: (27, 26), 3671: (31, 26), 3669: (29, 25), 3668: (28, 25), 3813: (35, 34), 3810: (39, 34), 3808: (37, 33), 3807: (36, 33), 3953: (43, 42), 3950: (47, 42), 3948: (45, 41), 3947: (44, 41), 4092: (67, 66), 4089: (71, 66), 4087: (69, 65), 4086: (68, 65), 4231: (75, 74), 4228: (79, 74), 4226: (77, 73), 4225: (76, 73), 4370: (91, 90), 4367: (95, 90), 4365: (93, 89), 4364: (92, 89), 4509: (99, 98), 4506: (103, 98), 4503: (
        100, 97), 4648: (107, 106), 4645: (111, 106), 4642: (108, 105), 4787: (115, 114), 4784: (119, 114), 4781: (116, 113), 4926: (123, 122), 4923: (127, 122), 4920: (124, 121), 15464: (83, 82), 15461: (87, 82), 15459: (85, 81), 15458: (84, 81), 15603: (51, 50), 15600: (55, 50), 15598: (53, 49), 15597: (52, 49), 21163: (59, 58), 21160: (63, 58), 21158: (61, 57), 21157: (60, 57), 32061: (3, 2), 32058: (7, 2), 32056: (5, 1), 32055: (4, 1), 32339: (11, 10), 32336: (15, 10), 32334: (13, 9), 32333: (12, 9)}

    res = {}
    bb = []
    for k, val in indici.items():
        p1, p2 = val
        cosi = []
        coppie = []
        for n1 in range(2):
            for n2 in range(2):
                B_true_input = [0]*128
                B_true_input[p1] = n1
                B_true_input[p2] = n2
                B_cur = [Bin[x] for Bin, x in zip(enc_B_all, B_true_input)]

                val = my_evaluate(garbled_circuit, (enc_A, B_cur), k)
                cosi.append(val)
                coppie.append((n1, n2))

        for j in range(4):
            if cosi.count(cosi[j]) == 1:
                uni = coppie[j]

        bb += [1-uni[0], 1-uni[1]]
    return bb
